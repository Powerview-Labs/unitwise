rules_version = '2';

/**
 * UNITWISE - FIRESTORE SECURITY RULES
 * Module 1: Authentication & Onboarding
 * 
 * SECURITY PRINCIPLES:
 * 1. Least Privilege: Users can only access their own data
 * 2. Authentication Required: No unauthenticated access to user data
 * 3. Backend-Only Operations: OTP sessions managed by Cloud Functions only
 * 4. Data Validation: Enforce schema and data types server-side
 * 5. Rate Limiting: Prevent abuse through Firestore query limits
 * 
 * COLLECTIONS PROTECTED:
 * - /users/{uid}: User profile data (uid-based access)
 * - /otp_sessions/{sessionId}: OTP verification data (backend-only)
 * - /tokens/{tokenId}: Token logging data (future module)
 * - /appliances/{applianceId}: User appliances (future module)
 * 
 * TESTING:
 * Use Firebase Emulator Suite to test these rules locally:
 * firebase emulators:start --only firestore
 * 
 * DEPLOYMENT:
 * firebase deploy --only firestore:rules
 */

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    /**
     * Check if request is authenticated
     * All authenticated requests have a valid request.auth object
     */
    function isAuthenticated() {
      return request.auth != null;
    }
    
    /**
     * Check if authenticated user owns the resource
     * Prevents users from accessing other users' data
     */
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    /**
     * Validate that required fields exist in the document
     * Prevents incomplete or malformed data writes
     */
    function hasRequiredUserFields() {
      let data = request.resource.data;
      return data.keys().hasAll(['uid', 'phone', 'name', 'disco', 'band', 'created_at']);
    }
    
    /**
     * Validate phone number format (E.164)
     * Example: +2348100000000
     */
    function isValidPhone(phone) {
      return phone.matches('^\\+[1-9]\\d{1,14}$');
    }
    
    /**
     * Validate email format (basic check)
     * Allows optional email field
     */
    function isValidEmail(email) {
      return email == null || email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }
    
    /**
     * Validate that user cannot modify sensitive fields
     * Prevents privilege escalation or data tampering
     */
    function cannotModifySystemFields() {
      let data = request.resource.data;
      let existing = resource.data;
      
      // Cannot change UID after creation
      return !('uid' in data.diff(existing).affectedKeys()) ||
             data.uid == existing.uid;
    }
    
    /**
     * Check if user is modifying only allowed fields
     * Restricts what users can update in their profile
     */
    function isValidUserUpdate() {
      let allowedFields = ['name', 'email', 'disco', 'band', 'location', 
                          'meter_number', 'theme', 'last_login', 'remember_me'];
      let changedFields = request.resource.data.diff(resource.data).affectedKeys();
      
      return changedFields.hasOnly(allowedFields);
    }
    
    // ============================================
    // COLLECTION: /users/{uid}
    // ============================================
    /**
     * User Profile Collection
     * 
     * READ: Only the authenticated user can read their own profile
     * WRITE: Only the authenticated user can create/update their own profile
     * DELETE: Users cannot delete their own profiles (use Firebase Auth deletion)
     * 
     * SECURITY ENFORCEMENTS:
     * - UID in document must match authenticated user's UID
     * - Phone number must be unique (enforced by Firestore index)
     * - Required fields must be present on creation
     * - Sensitive fields (uid, created_at) cannot be modified after creation
     * - Email and phone must pass format validation
     */
    match /users/{uid} {
      
      // READ: User can only read their own profile
      allow read: if isOwner(uid);
      
      // CREATE: User can create their own profile with valid data
      allow create: if isOwner(uid) 
                    && hasRequiredUserFields()
                    && isValidPhone(request.resource.data.phone)
                    && isValidEmail(request.resource.data.get('email', null))
                    && request.resource.data.uid == uid
                    && request.resource.data.created_at == request.time;
      
      // UPDATE: User can update their own profile (restricted fields)
      allow update: if isOwner(uid)
                    && isValidUserUpdate()
                    && cannotModifySystemFields()
                    && isValidPhone(request.resource.data.phone)
                    && isValidEmail(request.resource.data.get('email', null));
      
      // DELETE: Disabled - use Firebase Auth account deletion instead
      // Prevents orphaned data and ensures proper cleanup
      allow delete: if false;
    }
    
    // ============================================
    // COLLECTION: /otp_sessions/{sessionId}
    // ============================================
    /**
     * OTP Session Collection
     * 
     * READ: Backend Cloud Functions only (no client access)
     * WRITE: Backend Cloud Functions only (no client access)
     * DELETE: Backend Cloud Functions only (no client access)
     * 
     * SECURITY ENFORCEMENTS:
     * - Clients have ZERO access to OTP sessions
     * - Only Cloud Functions can create, read, or delete OTP sessions
     * - Prevents OTP tampering, brute force attacks, and session hijacking
     * - OTP hashes stored with bcrypt (never plaintext OTPs)
     * 
     * IMPLEMENTATION NOTES:
     * - Cloud Functions run with admin privileges and bypass these rules
     * - Client apps cannot read otpHash or compare OTPs directly
     * - Sessions auto-expire after 5 minutes (enforced in Cloud Functions)
     * - Max 5 verification attempts per session (enforced in Cloud Functions)
     */
    match /otp_sessions/{sessionId} {
      // All operations denied for clients
      // Only backend (admin SDK) can access this collection
      allow read: if false;
      allow write: if false;
      allow delete: if false;
    }
    
    // ============================================
    // COLLECTION: /tokens/{tokenId} (Future Module)
    // ============================================
    /**
     * Token Logging Collection
     * 
     * Placeholder rules for Module 2: Token Logger
     * Users will be able to create and read their own token entries
     */
    match /tokens/{tokenId} {
      // READ: User can read tokens where they are the owner
      allow read: if isAuthenticated() 
                  && resource.data.uid == request.auth.uid;
      
      // CREATE: User can create token entries for themselves
      allow create: if isAuthenticated()
                    && request.resource.data.uid == request.auth.uid
                    && request.resource.data.created_at == request.time;
      
      // UPDATE: User can update their own token entries (limited fields)
      allow update: if isAuthenticated()
                    && resource.data.uid == request.auth.uid
                    && request.resource.data.uid == request.auth.uid;
      
      // DELETE: User can delete their own token entries
      allow delete: if isAuthenticated()
                    && resource.data.uid == request.auth.uid;
    }
    
    // ============================================
    // COLLECTION: /appliances/{applianceId} (Future Module)
    // ============================================
    /**
     * Appliance Estimator Collection
     * 
     * Placeholder rules for Module 3: Appliance Estimator
     * Users will manage their appliance configurations
     */
    match /appliances/{applianceId} {
      // READ: User can read appliances where they are the owner
      allow read: if isAuthenticated()
                  && resource.data.uid == request.auth.uid;
      
      // CREATE: User can create appliances for themselves
      allow create: if isAuthenticated()
                    && request.resource.data.uid == request.auth.uid;
      
      // UPDATE: User can update their own appliances
      allow update: if isAuthenticated()
                    && resource.data.uid == request.auth.uid
                    && request.resource.data.uid == request.auth.uid;
      
      // DELETE: User can delete their own appliances
      allow delete: if isAuthenticated()
                    && resource.data.uid == request.auth.uid;
    }
    
    // ============================================
    // COLLECTION: /budgets/{budgetId} (Future Module)
    // ============================================
    /**
     * Budget Planner Collection
     * 
     * Placeholder rules for future budget planning feature
     */
    match /budgets/{budgetId} {
      allow read: if isAuthenticated()
                  && resource.data.uid == request.auth.uid;
      
      allow create: if isAuthenticated()
                    && request.resource.data.uid == request.auth.uid;
      
      allow update: if isAuthenticated()
                    && resource.data.uid == request.auth.uid;
      
      allow delete: if isAuthenticated()
                    && resource.data.uid == request.auth.uid;
    }
    
    // ============================================
    // DEFAULT DENY RULE
    // ============================================
    /**
     * Deny all access to any collection not explicitly allowed above
     * This is a critical security measure to prevent unauthorized access
     * to any future collections added without proper security rules
     */
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

/**
 * ============================================
 * FIRESTORE INDEXES REQUIRED
 * ============================================
 * 
 * The following indexes should be created in Firebase Console
 * or via firestore.indexes.json for optimal query performance:
 * 
 * 1. users collection:
 *    - Field: phone (Ascending, Unique)
 *      Purpose: Enforce phone number uniqueness
 *      Query: where('phone', '==', phoneNumber)
 * 
 *    - Field: email (Ascending)
 *      Purpose: Email lookup for support/admin queries
 *      Query: where('email', '==', email)
 * 
 *    - Field: created_at (Descending)
 *      Purpose: Sort users by registration date
 *      Query: orderBy('created_at', 'desc')
 * 
 * 2. otp_sessions collection:
 *    - Field: phone (Ascending)
 *      Purpose: Rate limiting queries
 *      Query: where('phone', '==', phone).where('createdAt', '>', timestamp)
 * 
 *    - Field: expiresAt (Ascending)
 *      Purpose: TTL cleanup queries
 *      Query: where('expiresAt', '<', now)
 * 
 * 3. tokens collection (future):
 *    - Composite: uid (Ascending) + created_at (Descending)
 *      Purpose: User-specific token history
 *      Query: where('uid', '==', uid).orderBy('created_at', 'desc')
 * 
 * ============================================
 * DEPLOYMENT CHECKLIST
 * ============================================
 * 
 * Before deploying to production:
 * 
 * □ Test all rules with Firebase Emulator Suite
 * □ Verify users cannot access other users' data
 * □ Verify OTP sessions are completely inaccessible to clients
 * □ Confirm required indexes are created
 * □ Test edge cases (missing fields, invalid data types)
 * □ Verify rate limiting works as expected
 * □ Audit rules with Firebase Rules Playground
 * □ Review Cloud Functions admin access patterns
 * □ Enable Firestore App Check in production
 * □ Set up monitoring and alerting for rule violations
 * 
 * ============================================
 * TESTING COMMANDS
 * ============================================
 * 
 * Test rules locally:
 * firebase emulators:start --only firestore
 * 
 * Deploy rules to production:
 * firebase deploy --only firestore:rules
 * 
 * Validate rules syntax:
 * firebase firestore:rules validate
 * 
 * ============================================
 */
